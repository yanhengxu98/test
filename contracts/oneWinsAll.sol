pragma solidity ^0.4.17;

contract oneWinsAll {
 // This is a smart contract for an ethereum-based lottery, in which one single winner is
 // picked based on a random number generated by the hash value of the blocks in ethereum,
 // whenever the number of participants reaches 25. All the currency paid by the participants
 // to join the game will be transferred then to that winner.
 // To participate in the game, one has to pay a certain price.
 // One has also to pick from 1-25 (included) a random integer as his ticket id.

    event purchased(address _user, uint64 _ticketid);
    event awardpaid(address _winner, uint64 _ticketid, uint64 _amount);
    // Events to be watched.
 
    uint64 public price = 0.05 ether; // A fixed price to join the game.
    uint64 public maxid = 2; // The max amount of tickets that can be sold out.

    uint64 public sold;     // Records the number of tickets sold.
    mapping(uint64 => address) players;

    constructor() public payable {
        sold = 0;
    }

    modifier allsold() {
     // Defines a state for the functions below that requires all tickets to be sold.
        require(sold == maxid);
        _;
    }

    function() public payable {
     // Fallback function.
        revert();
    }

    function join() payable public returns (bool) {
        require(msg.value == price);
        require(sold < maxid);
        // require(_ticket >= 1 && _ticket <= maxid);
        // Bugs, you don't know which ID is used.
        
        // Conditions for the player to join successfully and legally.

        // address user = msg.sender;
        sold += 1;
        players[sold] = msg.sender;
        emit purchased(msg.sender, sold);

        if (sold == maxid) {
         // The number of participants reaches the upper bound, time to send the award.
            sendrwrd();
        }
        return true;
    }

    function sendrwrd() public allsold payable returns (address) {
        uint64 winnerticket = picker();
        // address winner = players[winnerticket];
        // uint8 amount = maxid * price;

        // require(winner != address(0));
        // // Prevent locked funds by sending to bad address

        // reset();
        sold = 0;
        // Prevent re-entrancy attack by removing all arguments.
        players[winnerticket].transfer(maxid * price);
        emit awardpaid(players[winnerticket], winnerticket, maxid * price);
        return players[winnerticket];
    }

    function picker() public view allsold returns (uint64) {
        bytes memory entropy = abi.encodePacked(block.timestamp, block.number);
        bytes32 hash = sha256(entropy);
        return uint64(hash) % (maxid-1) + 1;
    }

    // function reset() private allsold returns (bool) {
    //     sold = 0;
    //     return true;
    // }

}
