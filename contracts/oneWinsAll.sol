pragma solidity ^0.4.17;

contract oneWinsAll {
	// This is a smart contract for an ethereum-based lottery, in which one single winner is
	// picked based on a random number generated by the hash value of the blocks in ethereum,
	// whenever the number of participants reaches 25. All the currency paid by the participants
	// to join the game will be transferred then to that winner.
	// To participate in the game, one has to pay a certain price.
	// One has also to pick from 1-25 (included) a random integer as his ticket id.

	event purchased(address indexed _user, uint64 _ticketid);
    event awardpaid(address indexed _winner,uint64 _ticketid, uint256 _amount);
    // Events to be watched.
 
    uint64 public price =  5; // A fixed price to join the game.
    uint64 public maxid = 25; // The max amount of tickets that can be sold out.

    uint256 public sold;			  // Records the number of tickets sold.
    address[26] public ticketmapping;

    constructor() public {
        sold = 0;
    }

    modifier allsold() {
    	// Defines a state for the functions below that requires all tickets to be sold.
        require(sold == maxid);
        _;
    }

    function() payable public {
    	// Fallback function.
        revert();
    }

    function join(uint64 _ticket) payable public returns (bool) {
        require(msg.value == price);
        require(_ticket >= 1 && _ticket <= maxid);
        require(ticketmapping[_ticket] == address(0));
        require(sold < maxid);
        // Conditions for the player to join successfully and legally.

        address user = msg.sender;
        sold += 1;
        ticketmapping[_ticket] = user;
        emit purchased(user, _ticket);

        if (sold == maxid) {
        	// The number of participants reaches the upper bound, time to send the award.
            sendrwrd();
        }
        return true;
    }

    function sendrwrd() public allsold returns (address) {
        uint64 winnerticket = picker();
        address winner = ticketmapping[winnerticket];
        uint256 amount = maxid * price;

        require(winner != address(0));
        // Prevent locked funds by sending to bad address

        reset();
        // Prevent re-entrancy attack by removing all arguments.
        winner.transfer(amount);
        emit awardpaid(winner, winnerticket, amount);
        return winner;
    }

    function picker() public view allsold returns (uint64) {
        bytes memory entropy = abi.encodePacked(block.timestamp, block.number);
        bytes32 hash = sha256(entropy);
        return uint64(hash) % maxid;
    }

    function reset() private allsold returns (bool) {
        sold = 0;
        delete ticketmapping;
        return true;
    }

    function getsold() public view returns(address[26]) {
        return ticketmapping;
    }
}