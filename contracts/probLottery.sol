pragma solidity ^0.4.17;

contract probLottery {
 // This is a smart contract for an ethereum-based lottery, in which one single winner is
 // picked based on a random number generated by the hash value of the blocks in ethereum,
 // whenever the number of participants reaches 25. All the currency paid by the participants
 // to join the game will be transferred then to that winner.
 // To participate in the game, one has to pay a certain single.
 // One has also to pick from 1-25 (included) a random integer as his ticket id.

    event purchased(address _user, uint64 _ticketid);
    event awardpaid(address _winner, uint64 _ticketid, uint64 _amount);
    // Events to be watched.
 
    uint64 public single= 500 wei; // A fixed single to join the game.
    uint64 public maxid = 2; // The max amount of tickets that can be sold out.

    uint8 public sold;     // Records the number of tickets sold.
    uint8 [] prob;
    mapping(uint64 => address) players;

    constructor() public payable {
        sold = 0;
    }

    modifier allsold() {
     // Defines a state for the functions below that requires all tickets to be sold.
        require(sold == maxid);
        _;
    }

    function() public payable {
     // Fallback function.
        revert();
    }

    function join() payable public returns (bool) {
        require(msg.value % single == 0 && msg.value != 0);
        require(sold < maxid);
        // Conditions for the player to join successfully and legally.

        sold += 1;
        players[sold] = msg.sender;
        for (uint i = 0; i < msg.value/single; i++) {
            prob.push(sold);
        }
        emit purchased(msg.sender, sold);

        if (sold == maxid) {
         // The number of participants reaches the upper bound, time to send the award.
            sendrwrd();
        }
        return true;
    }

    function sendrwrd() public allsold payable returns (address) {
        uint64 winnerticket = prob[picker()];
        uint8 multiplier = uint8(prob.length);

        sold = 0;
        // Prevent re-entrancy attack by removing all arguments.
        players[winnerticket].transfer(multiplier * single);
        emit awardpaid(players[winnerticket], winnerticket, multiplier * single);
        return players[winnerticket];
    }

    function picker() public view allsold returns (uint64) {
        bytes memory entropy = abi.encodePacked(block.timestamp, block.number);
        bytes32 hash = sha256(entropy);
        return uint64(hash) % (uint8(prob.length)-1) + 1;
    }

}
